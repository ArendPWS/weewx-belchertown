var moment_locale = "$system_locale_js";
moment.locale(moment_locale);

// http://stackoverflow.com/a/14887961/1177153
var weatherdirection = {
	0: 'N',
	90: 'E',
	180: 'S',
	270: 'W',
	360: 'N'
};

// From the front page
function get_cardinal_direction(degree) {
    if (degree >= 0 && degree <= 11.25) {
        return "N";
    } else if (degree >= 11.26 && degree <= 33.75) {
        return "NNE";
    } else if (degree >= 33.76 && degree <= 56.25) {
        return "NE";
    } else if (degree >= 56.26 && degree <= 78.75) {
        return "ENE";
    } else if (degree >= 78.76 && degree <= 101.25) {
        return "E";
    } else if (degree >= 101.26 && degree <= 123.75) {
        return "ESE";
    } else if (degree >= 123.76 && degree <= 146.25) {
        return "SE";
    } else if (degree >= 146.26 && degree <= 168.75) {
        return "SSE";
    } else if (degree >= 168.76 && degree <= 191.25) {
        return "S";
    } else if (degree >= 191.26 && degree <= 213.75) {
        return "SSW";
    } else if (degree >= 213.76 && degree <= 236.25) {
        return "SW";
    } else if (degree >= 236.26 && degree <= 258.75) {
        return "WSW";
    } else if (degree >= 258.76 && degree <= 281.25) {
        return "W";
    } else if (degree >= 281.26 && degree <= 303.75) {
        return "WNW";
    } else if (degree >= 303.76 && degree <= 326.25) {
        return "NW";
    } else if (degree >= 326.26 && degree <= 348.75) {
        return "NNW";
    } else if (degree >= 348.76 && degree <= 360) {
        return "N";
    }
}

Highcharts.setOptions({
    global: {
        //useUTC: false
        timezoneOffset: $highcharts_timezoneoffset
    },
    lang: {
        decimalPoint: '$highcharts_decimal'
    }
});

function daily () {
    
    var options = {
        chart: {
            renderTo: '',
            spacing: [5, 10, 10, 0],
            type: '',
            zoomType: 'x'
        },

        title: {
            text: ''
        },

        legend: {
            enabled: true
        },

        xAxis: {
            dateTimeLabelFormats: {
                day: '%e %b',
                week: '%e %b',
                month: '%b %y',
            },
            lineColor: '#555',
            minRange: 900000,
            minTickInterval: 900000,
            title: {
                style: {
                    font: 'bold 12px Lucida Grande, Lucida Sans Unicode, Verdana, Arial, Helvetica, sans-serif'
                }
            },
            ordinal: false,
            type: 'datetime'
        },

        yAxis: {
            endOnTick: true,
            lineColor: '#555',
            minorGridLineWidth: 0,
            startOnTick: true,
            showLastLabel: true,
            title: {
            },
			opposite: false
        },

        plotOptions: {
            line: {
                lineWidth: 2,
                gapSize: $archive_interval_ms, // archive_interval in milliseconds
                gapUnit: 'value',
                marker: {
                    enabled: false
                },
            }
        },
		// Define the plot colors in order as they are loaded below
		colors: ['#7cb5ec', '#434348', '#90ed7d', '#f7a35c', '#8085e9', '#f15c80', '#e4d354', '#8085e8', '#8d4653', '#91e8e1'],
		
		scrollbar: {
			enabled: false
        },
		navigator: {
			enabled: false
		},
		rangeSelector: {
			enabled: false
		},

        tooltip: {
            enabled: true,
            dateTimeLabelFormats: {
                hour: '%e %b %H:%M'
            },
            // For locale control with moment.js - https://api.highcharts.com/highcharts/tooltip.split
            formatter: function () {
                // The first returned item is the header, subsequent items are the points
                return [moment.unix( this.x / 1000).utcOffset($moment_js_utc_offset).format("LLL")].concat(
                    this.points.map(function (point) {
                        return "<span style='color:" + point.series.color + "'>\u25CF</span> " + point.series.name + ': ' + Highcharts.numberFormat(point.y);
                    })
                );
            },
            split: true,
        },

        series: [{}]

    };

    jQuery.getJSON('http://weewxlab/btownwx/json/day.json', function(data) {

        // Loop through each chart name (e.g. chart1, chart2, chart3)
        jQuery.each(data, function (plotname, obsname) {
            var observation_type, yaxis_min, yaxis_max = undefined;
            
            // Loop through each chart options
            jQuery.each(data[plotname]["options"], function (optionName, optionVal) {
                switch(optionName) {
                    case "type":
                        type = optionVal;
                        break;
                    case "renderTo":
                        renderTo = optionVal;
                        break;
                    case "title":
                        title = optionVal;
                        break;
                    case "yAxisLabel":
                        yAxisLabel = optionVal;
                        break;
                    case "yaxis_min":
                        yaxis_min = optionVal;
                        break;
                    case "yaxis_max":
                        yaxis_max = optionVal;
                        break;
                }
            });
            
            // Build the chart here with the data
            
            console.log( renderTo + ": building a " + type + " chart" ); // TODO: add to skin logging option
            
            // Set the chart render div and title
            options.chart.renderTo = renderTo;
            options.chart.type = type;
            options.title.text = title;
            
            // Reset the series everytime we loop.
            options.series = [];

            // Build the series
            var i = 0;
            jQuery.each(data[plotname]["series"], function (seriesName, seriesVal) {
                observation_type = data[plotname]["series"][seriesName]["obsType"];
                options.series[i] = data[plotname]["series"][seriesName];
                i++;
            });
            
            // Create the chart object
            var chart = new Highcharts.StockChart(options);
            
            // Set the chart yAxis label after the chart is created.
            chart.yAxis[0].setTitle({ text: yAxisLabel });
            
            // Some charts may require a defined min/max on the yAxis
            if (yaxis_min || yaxis_max) {
                // TODO change this to skin level logging
                console.log( renderTo + ": this chart has yAxis min or max set" );
                chart.yAxis[0].setExtremes(yaxis_min, yaxis_max);
            }
            
            // Barometer chart plots get a higher precision yAxis tick
            if (observation_type == "barometer") {
                chart.yAxis[0].update({
                    tickInterval: 0.01
                });
            } else {
                chart.yAxis[0].update({
                    tickInterval: null
                });            
            }
            
            // How to dynamically add a 2nd axis if there's more than 1 plot type
            // TODO figure this out?
            // chart.addAxis({ // Secondary yAxis
                // title: {
                    // text: 'Rainfall'
                // },
                // lineWidth: 2,
                // lineColor: '#08F',
                // opposite: true
            // });
            
            
            // Special handling for the windDir plot's tool tips, radius and yAxis
            if (observation_type == "windDir") {
                chart.update({
                    plotOptions: { series: { marker: { radius: 2 }, } }, // TODO make this user customizable? No complaints on it yet, and it suffers the same problem as yaxis extreme
                    tooltip: {
                        formatter: function() {
                            return moment.unix( this.x / 1000).utcOffset($moment_js_utc_offset).format("LLL") +'<br><b>' + get_cardinal_direction( parseFloat(this.point.y).toFixed(0) ) + ' (' + parseFloat(this.point.y).toFixed(0) + '\xBA)';
                        }
                    },
                    yAxis: {
                        tickInterval: 90,
                        showLastLabel: true,
                        labels: {
                            formatter: function() {
                                var value = weatherdirection[this.value];
                                return value !== 'undefined' ? value : this.value;
                            }
                        }
                    }
                });
            } else {
                // THIS IS SUCH A HACK. Any chart AFTER windDir has it's yAxis labels removed. This resets them back. 
                chart.update({ yAxis: { labels: { formatter: function() { return this.value; } } } });
            }
            
        });
    });

};
